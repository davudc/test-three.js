{"id":"src/shaders.js","dependencies":[{"name":"/project/sandbox/package.json","includedInParent":true,"mtime":1686852053065}],"generated":{"js":"var vertexShader = \"\\n  varying vec2 vUv;\\n  varying vec3 vPos;\\n\\n  void main() {\\n    vUv = uv;\\n    vPos = position;\\n\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\\n  }\\n\";\nvar fragmentShader = \"\\n  varying vec2 vUv;\\n  varying vec3 vPos;\\n\\n  uniform sampler2D uTexture;\\n  uniform float uTime;\\n\\n  void main() {\\n    float time = uTime * 0.5;\\n    vec2 repeat = -vec2(12., 3.);\\n    // To repeat the uvs we need to multiply them by a scalar\\n    // and then get the fractional part of it so they from 0 to 1\\n    // To move them continuously we have to add time\\n    // to the x or y component, to change the direction\\n    vec2 uv = fract(vUv * repeat - vec2(time, 0.)); // The sign of time change direction of movement\\n\\n    // Fake shadow\\n    float shadow = clamp(vPos.z / 5., 0., 1.);\\n\\n    vec3 texture = texture2D(uTexture, uv).rgb;\\n    // texture *= vec3(uv.x, uv.y, 1.); // To help visualize the repeated uvs\\n\\n    gl_FragColor = vec4(texture * shadow, 1.);\\n  }\\n\";\nmodule.exports = {\n  vert: vertexShader,\n  frag: fragmentShader\n};"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":1,"column":0},"source":"src/shaders.js","original":{"line":1,"column":0}},{"generated":{"line":1,"column":4},"source":"src/shaders.js","original":{"line":1,"column":6},"name":"vertexShader"},{"generated":{"line":1,"column":16},"source":"src/shaders.js","original":{"line":1,"column":18}},{"generated":{"line":1,"column":205},"source":"src/shaders.js","original":{"line":11,"column":1}},{"generated":{"line":2,"column":0},"source":"src/shaders.js","original":{"line":13,"column":0}},{"generated":{"line":2,"column":4},"source":"src/shaders.js","original":{"line":13,"column":6},"name":"fragmentShader"},{"generated":{"line":2,"column":18},"source":"src/shaders.js","original":{"line":13,"column":20}},{"generated":{"line":2,"column":808},"source":"src/shaders.js","original":{"line":37,"column":1}},{"generated":{"line":3,"column":0},"source":"src/shaders.js","original":{"line":39,"column":0},"name":"module"},{"generated":{"line":3,"column":6},"source":"src/shaders.js","original":{"line":39,"column":6}},{"generated":{"line":3,"column":7},"source":"src/shaders.js","original":{"line":39,"column":7},"name":"exports"},{"generated":{"line":3,"column":14},"source":"src/shaders.js","original":{"line":39,"column":14}},{"generated":{"line":3,"column":17},"source":"src/shaders.js","original":{"line":39,"column":17}},{"generated":{"line":4,"column":2},"source":"src/shaders.js","original":{"line":40,"column":2},"name":"vert"},{"generated":{"line":4,"column":6},"source":"src/shaders.js","original":{"line":40,"column":6}},{"generated":{"line":4,"column":8},"source":"src/shaders.js","original":{"line":40,"column":8},"name":"vertexShader"},{"generated":{"line":4,"column":20},"source":"src/shaders.js","original":{"line":40,"column":20}},{"generated":{"line":5,"column":2},"source":"src/shaders.js","original":{"line":41,"column":2},"name":"frag"},{"generated":{"line":5,"column":6},"source":"src/shaders.js","original":{"line":41,"column":6}},{"generated":{"line":5,"column":8},"source":"src/shaders.js","original":{"line":41,"column":8},"name":"fragmentShader"},{"generated":{"line":6,"column":0},"source":"src/shaders.js","original":{"line":42,"column":0}},{"generated":{"line":6,"column":1},"source":"src/shaders.js","original":{"line":42,"column":1}}],"sources":{"src/shaders.js":"const vertexShader = `\n  varying vec2 vUv;\n  varying vec3 vPos;\n\n  void main() {\n    vUv = uv;\n    vPos = position;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n  }\n`;\n\nconst fragmentShader = `\n  varying vec2 vUv;\n  varying vec3 vPos;\n\n  uniform sampler2D uTexture;\n  uniform float uTime;\n\n  void main() {\n    float time = uTime * 0.5;\n    vec2 repeat = -vec2(12., 3.);\n    // To repeat the uvs we need to multiply them by a scalar\n    // and then get the fractional part of it so they from 0 to 1\n    // To move them continuously we have to add time\n    // to the x or y component, to change the direction\n    vec2 uv = fract(vUv * repeat - vec2(time, 0.)); // The sign of time change direction of movement\n\n    // Fake shadow\n    float shadow = clamp(vPos.z / 5., 0., 1.);\n\n    vec3 texture = texture2D(uTexture, uv).rgb;\n    // texture *= vec3(uv.x, uv.y, 1.); // To help visualize the repeated uvs\n\n    gl_FragColor = vec4(texture * shadow, 1.);\n  }\n`;\n\nmodule.exports = {\n  vert: vertexShader,\n  frag: fragmentShader\n};\n"},"lineCount":null}},"error":null,"hash":"769d158ce2167f37559dd35d1bff5cca","cacheData":{"env":{}}}